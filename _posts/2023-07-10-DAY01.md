### 나름의 감상문 🤔

자바만 사용하다가 이렇게 자바스크립트로 코드를 작성한 적이 처음이라 콘솔에 입력받는 것부터 난관이었다. 무슨 정신으로 코드(슬액희)를 작성했는지 모르겠다. 나름 가볍게 기능 구현 목록과 흐름을 작성하고 출발했는데, **좀 더 효율적인 방법은 없었을까** 고민하고 시작하는게 나았을 것 같다.

- 효율적이 풀이 방법에 대한 고민

- 구현 운용의 문제점

아직도 하나의 기능을 구현하고 잘 동작하는지 순차적으로 확인해봐야 하는데, 확인도 않고 바로 다음 구현으로 넘어가려고 한다. 내일부터는 **1기능 1동작** 무조건 확인하고 갈 것이다!!

내일은 더 꼼꼼히 기능 구현 목록과 문제 해결 과정을 작성해봐야겠다! JS의 기본 문법도 어느정도 눈에 익히고 들어가야지..!

## gist 사용하기

지금은 상단이 `Github Gist`로 되어있지만 처음 깃허브를 들어갔을 때 gist로 접속하고 싶다면 오른쪽 위의 `+` 버튼을 누르면 된다!

이후 리드미 파일을 작성한 뒤 `Clone 주소`로 변경하고 로컬에 폴더를 생성한 뒤 add&commit&push의 과정을 진행한다. (다시 보니 txt 파일로 생성했다.. ~~미쳤나보다~~..)

어제 자기 전에 gist를 봤을 땐 리포지토리 같은 느낌이 아니라 생성하고 커밋하는 것이 굉장히 불편해 보였는데 익숙해지고 나니 나쁘지 않은 것 같다. (다만 파일이 많아지면 힘들 것 같다…)

## 콘솔에 값 입력받기

요구사항을 보고 함수를 호출하며 입력값을 넣을까 싶었지만, 앞으로 콘솔 창을 통해 입력받을 과제들이 많지 않을까 싶어 입력받기를 도전해봤다! ~~역시 아무것도 모르면 거칠게 없다~~

`require()` 메서드를 활용해 `readline` 모듈을 가져온다. (사실 이러면 입력창 뜰 줄 알았다… 바보..)

이후 `createInterface` 메서드를 활용해 객체를 만들어 사용자가 콘솔에 입력할 때 그 값을 받아올 수 있도록 한다! 여기서 `close()`함수를 사용해 무한 입력을 막는다. 입력값을 받아올 때는 `on()` 함수를 사용하는데 여기서 입력값을 받아 앞으로 사용될 함수들의 인자로 넣어줘야 한다. (왜 이래야 로직이 돌아가는 걸까? 더 알아봐야겠다)

## JavaScript의 구조체 및 기본형들과 친해지기,,

오늘만 해도 구글링을 야무지게 했다. (학습메모에서도 적어놨지만)

- 문자열 다루는 방법 (ex. split, substr)
  `문자열.split(쪼개는 기준)` : 쪼개는 기준으로 잘린 문자열을 배열로 return해주는 함수
  `문자열.substr(숫자1, 숫자2)`: 숫자1의 인덱스부터 숫자2 길이까지의 문자열을 잘라 새로운 문자열로 만들어주는 함수
- JS 배열 다루기
  - JavaScript에서 배열을 선언하는 방식은 두가지!!
  1. `let arr = []` 빈 배열 선언하기
  2. `let arr = new Array(10)` 크기가 정해진 배열 생성자로 선언하기
  - 만약 2차원 배열을 선언하고 싶다면?!
    바깥에서 `let arr = new Array(10)`을 선언한 뒤,
    for문을 활용하여 `arr[i] = new Array(20)` 세부 인덱스도 배열로 선언해주면 됨!
- 정규표현식
  - 주어진 문자열이 정규 표현식을 만족하는지 확인하는 메서드 ⇒ `test`
    ex. `/^[a-zA-Z]*$/` 주어진 문자열이 영어를 포함하는지 확인
    (이번 과제에서는 주어진 해당 시간표의 이름이 영어/한글 인지 구별을 위해 작성했다)
  - 주어진 문자열의 특정 문자만 특정 문자로 대체하는 메서드 ⇒ `replace`
    ex.
    ```jsx
    let num =  /[0-9]/gim;
    const a = 19adf5;
    console.log(a.replace(num, ")); //adf
    ```

## 스스로 확인!

- **정수형을 지원한다고 가정하고 구현할 경우와 문자열로 타입이 바뀌는 경우 각각 어떤 부분이 달라졌는지 설명한다.**

  - JavaScript는 암묵적인 타입 변환이 이뤄지게 되어 문자열끼리 빼기 연산을 진행하게 되면, 개발자의 의도와는 상관없이 숫자 형태로 값이 반환된다.
    ex.

  ```jsx
  const a = "12" - "2";
  console.log(a); //10
  console.log(typeof a); //number

  const b = "12" + "2";
  console.log(b); //122

  const c = "12" + 2;
  console.log(c); //122
  ```

  그러나 이는 뺄셈 기준이며 덧셈 연산을 진행하게 되면 두 문자가 이어진 새로운 문자열이 된다.

- **함수를 여러 개로 분리해서 만들면서 어떤 기준으로 함수를 분리했는지 설명한다.**
  정신없이 코드를 작성하다 보니 10줄이 넘어갈 때 같은 기능을 구현을 위해 작성한 코드끼리 나눠 함수로 분리시킨 것 같다. (사실 함수로 깔끔하게 분리했다기 보다는 10줄 제한사항 때문에 분리한 것 같아 아쉬움이 남는다ㅠㅠ)
- **GitHub 저장소에 Pull Request 보내기 위한 과정에서 사용하는 git 명령과 명령별 옵션을 확인해본다.**

  1. 기여 저장소 `fork` ⇒ 이는 원하는 리포지토리를 들어가면 친절하게 찾을 수 있다!!
  2. `fork` 해온 리포지토리를 로컬 저장소에 `clone` 해오기

     `git clone ~.git` 명령어 입력

     (사실 나는 `gitkraken`을 활용해 github 계정과 연동하여 편하게 clone 해왔었다.. 원하는 경로에 알아서 `clone` 시켜줌..)

  3. 원격 저장소 remote 설정

     `git remote add 원격저장소_이름 1번의_기여저장소.git`

  4. Pull Request를 위한 branch 생성

     (clone해온 원래 브랜치는 master이지만 Pull Request를 보낼 다른 branch를 만들어야 하므로)

     `git checkout -b 원하는_브랜치명` (여기서 b는 branch인듯..?)

  5. 4번에서 생성한 branch에 push!

     `git push origin 원하는_브랜치명`

  6. 5번까지의 과정을 통해 `github` 페이지에서 PR이 승인돼 merge 되었다면, 만들어놓은 브랜치는 삭제!

     `git branch -D 원하는_브랜치명`

## 피어

- **git 주소를 가져와서 commit하고 push할 때까지 흐름에 대해서 각자 이해한 내용을 설명하고 다른 사람 설명과 차이점이 있는지 비교한다.**
  `commit`은 로컬 저장소에 저장이 되고, `push` 는 리포지토리(원격 저장소)에 기록을 하는 명령어이다. 로컬 공간에서 코드를 작성하고 `add`를 통해 `staging area`에 파일이 추가한 뒤 로컬 저장소의 변경 사항을 원격 저장소에 갱신하고 싶다면 `push` 를 활용한다.
- **git add와 commit을 할때 git 내부에서는 어떤 동작이 일어나는 것인지 자료를 찾아 학습하고 이를 비교해서 정리한다.**
  `git`에는 3가지 영역이 있다.
  1. working directory
  2. staging area
  3. repository
     working directory는 로컬 공간에서 우리가 자유롭게 코드를 수정하는 공간이다. staging area는 리포지토리에 커밋이 되기 전에, 파일을 올려놓는 영역(로컬에 기록)이다. `add` 명령어(1→2)는 다음 변경을 리포지토리에 기록하기 전까지 모든 변경을 모아놓기 위해 사용한다. `commit` 명령어(2→3)는 `add`를 통해 저장된 파일들을 로컬 저장소에 업데이트 해준다.
- **VSCode 와 터미널에서 실행 환경이 같은 점과 다른 점을 비교해서 정리한다.**
  - `VSCode`는 통합 개발 환경(IDE/Integrated Development Environment)로 , 프로그래머가 SW 코드를 효율적으로 개발하도록 돕는 SW 어플리케이션이다. 따라서 여러 유틸리티를 수동으로 설정할 필요가 없이 새로운 어플리케이션 프로그래밍을 신속히 시작할 수 있다. `터미널`은 컴퓨터를 직접 제어하기 위해 사용하는 SW(CLI)이다. 주로 더 많은 명령과 스크립트에 접근할 때 터미널을 선호한다. CLI는 GUI에 비해 비교적 애플리케이션 간의 입출력 전달이나 자동화가 간단하다.
  - 터미널 환경에서 해당 프로젝트를 직접 빌드하는 방법도 찾아본다.
    (이번 미션을 진행하면서 해당 프로젝트를 직접 빌드하여 출력값을 확인하였다. `node 파일이름.js` )

#### 참고 ⇒

    https://aws.amazon.com/ko/what-is/ide/
    [https://inpa.tistory.com/entry/백엔드-로드맵-💻-터미널이란](https://inpa.tistory.com/entry/%EB%B0%B1%EC%97%94%EB%93%9C-%EB%A1%9C%EB%93%9C%EB%A7%B5-%F0%9F%92%BB-%ED%84%B0%EB%AF%B8%EB%84%90%EC%9D%B4%EB%9E%80)
    https://jenny-jo55.tistory.com/7
    https://chanhuiseok.github.io/posts/git-3/
